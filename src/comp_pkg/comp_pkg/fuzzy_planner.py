#!/usr/bin/env python3
import math
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu
from std_msgs.msg import Float32
import numpy as np
from nav_msgs.msg import Path, Odometry
from geometry_msgs.msg import PointStamped, Twist
def angle_wrap(a):
    """Wrap angle to [-pi, pi]."""
    return (a + np.pi) % (2 * np.pi) - np.pi

class FuzzyPathPlanner(Node):
    def __init__(self, num_waypoints=100,waypoint_tolerance=1.0):
        super().__init__('fuzzy_path_planner_node')



        # Subscriptions
        self.create_subscription(Path, '/plan', self.plan_callback, 10)
        self.create_subscription(Odometry, '/odom', self.odom_callback, 10)
        self.create_subscription(PointStamped, '/closest_obstacle_in_range', self.closest_obstacle_callback, 10)
        self.create_subscription(Float32, '/robot0_0/yaw_deg', self.yaw_callback, 10)

        # Publisher for fuzzy cmd_vel
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel_fuzzy', 10)



        # Timer to update waypoint following
        self.create_timer(0.5, self.follow_waypoints)
        self.dt = 0.1  # 10 Hz control loop
        self.create_timer(self.dt, self.control_loop)

        self.theta = 0.0  # current heading in radians
        # catch waypoints of the static path generated by nav2
        self.num_waypoints = num_waypoints
        # the parameter that determine when the code go to the next waypoint
        self.waypoint_tolerance = waypoint_tolerance
        self.current_wp_index = 0
        self.waypoints = None  # Will be a numpy array of shape (N, 2)

        # get rect_obj position and velocity from odom topic 
        self.rect_obj_position=np.array([0,0]).reshape(1,2)
        self.rect_obj_velocity=np.array([0,0]).reshape(1,2)

        # current way point that is a single part of waypoints array that changes while the robot moves
        self.current_way_point=np.array([0,0]).reshape(1,2)
                
        # array in the shape of (num obs,2)
        # get the position and velocity of closest obstacle from closest_obstacle_in_range topic
        self.position_obstacles=np.array([10,0]).reshape(1,2)
        self.velocity_obstacles=np.array([0,0]).reshape(1,2)
        
        self.k_att=10
        self.max_v_leader=1
        self.max_omega_leader=1
        self.r_safe_min=1.0
        self.k_rep_p=100
        self.k_rep_v=100

        # Constants for r_safe calculation (these are find experimentally and should be improved)
        self.kv = 2
        self.ka = 1

    def plan_callback(self, msg: Path):
        """Catch static path waypoints from Nav2 once."""
        if self.waypoints is not None:
            return

        total = len(msg.poses)
        if total == 0:
            self.get_logger().warn("Received empty path!")
            return

        # Downsample waypoints
        step = max(1, total // self.num_waypoints)
        points = [
            (msg.poses[i].pose.position.x, msg.poses[i].pose.position.y)
            for i in range(0, total, step)
        ][:self.num_waypoints]

        self.waypoints = np.array(points)
        self.current_way_point = self.waypoints[0].reshape(1, 2)

        self.get_logger().info(
            f"Received {total} poses → reduced to {self.waypoints.shape[0]} waypoints."
        )


    def odom_callback(self, msg: Odometry):
        """Update robot position and velocity from odometry."""
        x = msg.pose.pose.position.x
        y = msg.pose.pose.position.y
        self.rect_obj_position = np.array([x, y]).reshape(1, 2)

        vx = msg.twist.twist.linear.x
        vy = msg.twist.twist.linear.y
        self.rect_obj_velocity = np.array([vx, vy]).reshape(1, 2)


    def closest_obstacle_callback(self, msg: PointStamped):
        """Update closest obstacle position (velocity left as 0)."""
        x = msg.point.x
        y = msg.point.y
        self.position_obstacles = np.array([x, y]).reshape(1, 2)

    def yaw_callback(self, msg: Float32):
        # Convert degrees → radians
        self.theta = np.deg2rad(msg.data)

    def follow_waypoints(self):
        """Update current waypoint based on proximity."""
        if self.waypoints is None:
            return

        if self.current_wp_index >= len(self.waypoints):
            self.get_logger().info("Reached final waypoint.")
            return

        goal_position = self.waypoints[self.current_wp_index].reshape(1, 2)
        self.current_way_point = goal_position

        # Distance to current goal
        dist = np.linalg.norm(self.rect_obj_position - goal_position)

        self.get_logger().info(
            f"Current WP {self.current_wp_index}: {goal_position.flatten()}, "
            #f"Robot pos: {self.rect_obj_position.flatten()}, dist: {dist:.2f}"
        )
        # Move to next waypoint if close enough
        if dist <= self.waypoint_tolerance:
            self.current_wp_index += 1
            #if self.current_wp_index < len(self.waypoints):
               # self.get_logger().info(
               #     f"Switching to waypoint {self.current_wp_index}: {self.waypoints[self.current_wp_index]}"
               # )
            #else:
            #    self.get_logger().info("All waypoints completed!")

    def attractive_part(self):
        diff = self.current_way_point - self.rect_obj_position
        distance = np.linalg.norm(diff)
        if distance == 0:
            return np.zeros_like(diff)
        # Unit direction vector from leader to goal
        direction = diff / distance
        # Apply a constant magnitude force (capped by max_v_leader)
        F_att = self.k_att * direction
        F_att = 1*np.clip(F_att, 10*-self.max_v_leader , 10*self.max_v_leader)     

        return F_att
    
    def repulsive_part(self):

        num_obs=self.position_obstacles.shape[0]
        # Initialize repulsive forces
        F_rep_p = np.array([np.zeros(2, dtype=np.float64)])
        F_rep_v = np.array([np.zeros(2, dtype=np.float64)])

        for i in range(num_obs): # in this loop we will be calculating cos_delta and threat level to use in repulsive potential
            # Calculate relative position and velocity
            p_relative = self.position_obstacles[i] - self.rect_obj_position
            velocity_relative = self.rect_obj_velocity - self.velocity_obstacles[i]
            # Calculate distance to obstacle
            dist_relative = np.linalg.norm(p_relative)
            # Calculate angle between relative position and relative velocity. this angle shows us that the obstacle and our object will be colliding or not. if cos_delta>0
            # then they will be colliding 
            if dist_relative == 0 or np.linalg.norm(velocity_relative) == 0:
                cos_delta = 0.0
            else:
                cos_delta = np.dot(p_relative, velocity_relative.T) / (dist_relative * np.linalg.norm(velocity_relative))
            delta = np.arccos(np.clip(cos_delta, -1, 1))
            # Calculate variable safety radius. the safety radius is the measure that act as on off switch in repulsive force calculation. r_safe=r_min_safe+r_var_safe
            if cos_delta > 0: # if cos_delta>0 -> the obstacle and our object are in dangerous situation -> r=r_safe+r_var_safe
                r_var_safe = (self.kv / (self.ka + self.max_omega_leader)) * np.linalg.norm(velocity_relative) * np.cos(delta) 
                # kv and ka are constants. max omega leader is in the denominator which is true. relative velocity and cos_delta have direct impact on r_var safe
                r_safe = self.r_safe_min + r_var_safe
            else:
                r_safe = self.r_safe_min
            # Calculate threat level
            if cos_delta > 0 and dist_relative > 0: # threat level is another factor that improve our dynamic collision avoidance
                TH_level = (1/dist_relative - 1/r_safe) * np.linalg.norm(velocity_relative) * np.cos(delta) # this factor has inverse relation with dis_relative and                                                                                            #direct relation with norm(velocity) and cos_delta
            else:
                TH_level = 0
            # repulsive force in potential field method has 2 parts. the first part happen because of the dist relative of obstacle and rectangular object.
            # Update forces if in danger zone
            if (dist_relative < r_safe) and (cos_delta > 0):
                # Position-based repulsive force
                F_rep_p += self.k_rep_p * TH_level * (-p_relative / dist_relative)
                # Velocity-based repulsive force. this is the second part of potential field repulsive force.
                if np.linalg.norm(velocity_relative) > 0:
                    F_rep_v += self.k_rep_v * TH_level * ((-p_relative/dist_relative) * (1/cos_delta) +velocity_relative/np.linalg.norm(velocity_relative))
        # Total repulsive force
        F_t = F_rep_p + F_rep_v
        return F_t

    def fuzzy_planner(self):

        # Calculate attractive force
        F_att = self.attractive_part()
        F_rep=self.repulsive_part()
        # Total force
        F_total = F_att + F_rep
        # Convert resultant force to velocity commands
        theta_d = np.arctan2(F_total[0][1], F_total[0][0])  # Desired heading angle. this is the angle of potential field force
        v_d = 1*(F_total / 20) # 20 is the number that have reached experimentally (need to be work on)
        # Limit linear velocity
        if np.linalg.norm(v_d) > self.max_v_leader:
            v_d = (v_d / np.linalg.norm(v_d)) * self.max_v_leader
        
        v_d =2* np.linalg.norm(v_d)
        # Angular velocity based on yaw error
        omega_d =  angle_wrap(theta_d - self.theta) / self.dt
        omega_d = np.sign(omega_d) * min(abs(omega_d), self.max_omega_leader)
        self.get_logger().info(
            f" theta_d = {np.rad2deg(theta_d):.1f}, theta = {np.rad2deg(self.theta):.1f} °"
        )
        return v_d, omega_d 

    def control_loop(self):
        # Update waypoint
        self.follow_waypoints()
        # If no path loaded yet, don't command motion
        if self.waypoints is None or self.current_wp_index >= (len(self.waypoints) if self.waypoints is not None else 0):
            twist = Twist()
            self.cmd_pub.publish(twist)
            return

        # Run fuzzy planner
        v_d, omega_d = self.fuzzy_planner()

        # Publish ABSOLUTE values (per your request) for a differential drive:
        twist = Twist()
        twist.linear.x  = float((v_d))
        twist.angular.z = float((omega_d))
        # Ensure diff-drive compliant fields:
        twist.linear.y = 0.0
        twist.linear.z = 0.0
        twist.angular.x = 0.0
        twist.angular.y = 0.0

        self.cmd_pub.publish(twist)

        # Optional: brief debug
        self.get_logger().info(f"cmd_vel_fuzzy → v={twist.linear.x:.2f} m/s, ω={twist.angular.z:.2f} rad/s")

        #self.get_logger().info(
        #    f"Planner output: v = {v_d}, omega = {omega_d:.2f}, theta = {np.rad2deg(self.theta):.1f} °"
        #)


def main(args=None):
    rclpy.init(args=args)
    node = FuzzyPathPlanner(num_waypoints=100, waypoint_tolerance=0.4)  
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()

#ros2 action send_goal /navigate_to_pose nav2_msgs/action/NavigateToPose "{pose: {header: {frame_id: 'map'}, pose: {position: {x: -14.0, y: 0.0, z: 0.0}, orientation: {w: 1.0}}}}"






